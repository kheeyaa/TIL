// 6. 최대 선호 음식(DFS)
// 엘리트 학원에서 선생님과 학생들이 소풍을 갔습니다. 선생님들은 학생들에게 요리를 해주기
// 로 마음먹고, 학생들에게 각자의 취향에 대해서 물었다.
// 선생님들이 가지고 있는 양념재료의 종류는 D(1≤D≤15)종류입니다, 양념재료는 1부터 D까지
// 번호로 매겨져 있다. 각각의 학생들은 자기가 원하는 재료가 꼭 다 들어가야만 음식을 먹겠다
// 고 합니다.
// 학생들은 총 N(1≤N≤30,000)명이 있고, 선생님이 사용할 수 있는 재료의 종류가 K(1≤K≤D)
// 개 이하가 되도록 하려 한다. 위의 조건을 만족하면서 최대 몇 명의 학생에게 음식을 만들어
// 줄 수 있는지 구하는 프로그램을 작성하세요.
// ▣ 입력설명
// 매개변수 nums 배열에 1번 학생부터 N번 학생까지의 음식취향에 관한 정보가 주어진다. 배열
// 의 원소는 학생이 좋아하는 재료의 번호이다. 재료의 번호는 1부터 D까지의 정수로 나타낸다.
// 원하는 재료가 없는 학생은 아무거나 먹겠다는 뜻으로 해석한다. 그 다음 D와 K가 입력된다.
// ▣ 출력설명
// 조건을 만족하는 최대인원을 반환합니다.
// ▣ 매개변수 형식
// [[1], [2, 3], [3], [1, 2], [], [2, 1], [2, 3, 4], [3, 4]], 4, 3
// ▣ 반환값 형식
// 6
// 입출력설명:
// nums 배열이 다음과 같다면 [[1], [2, 3], [3], [1, 2], [], [2, 1], [2, 3, 4], [3, 4]]
// 1번 학생은 1번 재료가 꼭 들어가야 먹으며, 2번학생은 2번과 3번 재료가 꼭 들어가야 먹습니
// 다. 5번학생은 원하는 재료가 없으므로 아무거나 먹겠다는 뜻입니다.
// 출력은 1, 2, 3번 재료를 사용해 음색을 만들면 1, 2, 3, 4, 5, 6번 학생들이 음식을 먹을 수
// 있어 최대인원은 6명입니다.

// - dCk = 내가 만들 수 있는 음식의 종류
// - 비트 연산자로 해결한다
// A & B = A 이면, A는 B의 부분집합이다.
// - 양념통 가중치 & 학생 양념 가중치 = 학생 이면, 학생은 먹을 수 있음!
// 양념 : 1, 2, 3, 4, ...
// 가중치 : 1, 2, 4, 8, ...
// 1,2 양념 => 1+2 = 3
// 2,3,4 양념 => 2+4+8 = 14

{
  function solution(nums, d, k) {
    let n = nums.length; // 학생수
    let st = Array.from({ length: n }, () => 0); // 학생
    let answer = Number.MIN_SAFE_INTEGER;
    let pow = Array.from({ length: d + 1 }, () => 0); // 양념 번호에 가중치.

    // pow의 인덱스 번호 = 양념 인덱스 번호
    // pow의 값은 가중치
    pow[1] = 1;
    for (let i = 2; i <= d; i++) {
      pow[i] = pow[i - 1] * 2;
    }

    // 학생마다 양념통 가중치 값을 정함.
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < nums[i].length; j++) {
        // 학생이 좋아하는 양념 갯수만큼 반복
        st[i] += pow[nums[i][j]];
      }
    }

    // 양념을 조합으로 선택함.
    function DFS(L, s, bit) {
      if (L === k) {
        // 양념통 다 고름
        let cnt = 0; // 몇명이 먹을까?
        for (let j = 0; j < n; j++) {
          if ((bit & st[j]) === st[j]) {
            // 학생과 음식의 and연산 결과가 학생이라면, 음식은 학생이 먹을 수 있는 것
            cnt++;
          }
        }
        answer = Math.max(answer, cnt);
      } else {
        // i는 양념번호. 양념을 랜덤으로 깊이 k만큼 선택할 것이다
        for (let i = s; i <= d; i++) {
          DFS(L + 1, i + 1, bit + pow[i]);
        }
      }
    }

    DFS(0, 1, 0);
    return answer;
  }
  //   console.log(
  //     solution([[1], [2, 3], [3], [1, 2], [], [2, 1], [2, 3, 4], [3, 4]], 4, 3)
  //   ); //6
}
