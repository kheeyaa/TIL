// 2. 경로 탐색(인접행렬) => DFS(경우의 수)
// 근데 경우의 수가 많아지면 복잡도 올라감... 인접리스트!!
// - 경로 : 한번 방문하면 그다음엔 방문하면 안돼!
// 방향그래프가 주어지면 1번 정점에서 N번 정점으로 가는 모든 경로의 가지 수를 출력하는 프
// 로그램을 작성하세요. 아래 그래프에서 1번 정점에서 5번 정점으로 가는 가지 수는
// 1 2 3 4 5
// 1 2 5
// 1 3 4 2 5
// 1 3 4 5
// 1 4 2 5
// 1 4 5
// 총 6 가지입니다.
// ▣ 입력설명
// 매개변수 n에 정점의 수 N(1<=N<=20)주어집니다. 이차원 배열 edges에 간선의 정보가 주어
// 집니다.
// ▣ 출력설명
// 총 가지수를 반환합니다.
// ▣ 매개변수 형식 1
// 5, [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 5], [3, 4], [4, 2], [4, 5]]
// ▣ 반환값 형식 1
// 6
// 입력설명 : [a, b]는 a정점에서 b정점으로 이동할 수 있다는 의미입니다.
{
  function solution(n, edges) {
    let answer = 0;
    let graph = Array.from(Array(n + 1), () => Array(n + 1).fill(0));
    let ch = Array.from({ length: n + 1 }, () => 0); // 방문했는지..

    // 인접행렬 완성
    for (let [a, b] of edges) {
      graph[a][b] = 1; // 행=>열로 갈 수 있음
    }
    let path = []; // 경로 들렸는지 확인함.

    function DFS(v) {
      if (v === n) {
        // 종료 시점
        answer++;
        console.log(path); // 1=>5 들린 경로를 출력함.
      } else {
        for (let i = 1; i <= n; i++) {
          // v 정점에서 i 정점으로 갈 수 있는지 확인함. 정점을 방문도 안했어야함.
          if (graph[v][i] === 1 && ch[i] === 0) {
            ch[i] = 1;
            path.push(i);
            DFS(i);
            // 다음 정점은 i이다
            ch[i] = 0;
            path.pop();
            // 체크 풀림.
          }
        }
      }
    }

    ch[1] = 1; // 1번 방문했음
    path.push(1); // 처음 경로 삽입해야함.
    DFS(1);
    return answer;
  }
  //   console.log(
  //     solution(5, [
  //       [1, 2],
  //       [1, 3],
  //       [1, 4],
  //       [2, 1],
  //       [2, 3],
  //       [2, 5],
  //       [3, 4],
  //       [4, 2],
  //       [4, 5],
  //     ])
  //   );
}
