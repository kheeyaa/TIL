// 3. 회장뽑기(플로이드-와샬 응용)
// 월드컵축구의 응원을 위한 모임에서 회장을 선출하려고 한다. 이모임은 만들어진지 얼마 되지
// 않았기 때문에 회원사이에 서로 모르는 사람도 있지만, 몇 사람을 통하면 서로 모두 알 수 있
// 다.
// 각 회원은 다른 회원들과 가까운 정도에 따라 점수를 받게 된다.
// 예를 들어 어느 회원이 다른 모든 회원과 친구이면, 이 회원의 점수는 1점이다. 어느 회원의
// 점수가 2점이면, 다른 모든 회원이 친구이거나, 친구의 친구임을 말한다. 또한, 어느 회원의
// 점수가 3점이면, 다른 모든 회원이 친구이거나, 친구의 친구이거나, 친국의 친구의 친구임을
// 말한다.4점, 5점등은 같은 방법으로 정해진다.
// 각 회원의 점수를 정할 때 주의할 점은 어떤 두 회원이 친구 사이이면서 동시에 친구의 친구
// 사이이면, 이 두 사람은 친구사이라고 본다. 회장은 회원들 중에서 점수가 가장 작은 사람이
// 된다.
// 회장의 점수와 회장이 될 수 있는 모든 사람을 찾는 프로그램을 작성하시오.
// ▣ 입력설명
// 매개변수 n에는 회원의 수가 있다.
// 단, 회원의 수는 50명을 넘지 않는다.
// 친구 관계를 나타내는 두 개의 회원번호가 순서쌍으로 있는 정보가 edges에 주어진다.
// ▣ 출력설명
// 회장 후보의 점수와 회장후보 수를 반환한다.
// ▣ 입력예제 1
// 5, [[1, 2], [2, 3], [3, 4], [4, 5], [2, 4], [5, 3]]
// ▣ 출력예제 1
// [2, 3]
{
  function solution(n, edges) {
    let answer = [];
    let dist = Array.from(Array(n + 1), () => Array(n + 1).fill(1000));
    for (let i = 0; i < n + 1; i++) {
      dist[i][i] = 0;
    }
    for (let [a, b] of edges) {
      // 무방향
      dist[a][b] = 1;
      dist[b][a] = 1;
    }

    for (let k = 1; k <= n; k++) {
      for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= n; j++) {
          dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
        }
      }
    }

    let PS = 100;
    let score = Array.from(Array(n + 1), () => 0);
    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= n; j++) {
        if (i === j) continue;
        score[i] = Math.max(score[i], dist[i][j]);
      }
      PS = Math.min(PS, score[i]);
    }
    answer.push(PS);
    let cnt = 0;
    for (let i = 1; i <= n; i++) {
      if (score[i] === PS) cnt++;
    }
    answer.push(cnt);
    return answer; // 2점이 3명
  }
  //   console.log(
  //     solution(5, [
  //       [1, 2],
  //       [2, 3],
  //       [3, 4],
  //       [4, 5],
  //       [2, 4],
  //       [5, 3],
  //     ])
  //   );
}
